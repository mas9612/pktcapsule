package main

import (
	"bytes"
	"context"
	"reflect"
	"testing"

	pb "github.com/mas9612/pktcapsule"
)

var encapsulateTests = []struct {
	in  *pb.EncapsulateRequest
	out *pb.Packet
}{
	{
		&pb.EncapsulateRequest{
			Data: []byte{
				0x45, 0x00, 0x00, 0x34, 0x00, 0x00, 0x40, 0x00, 0x40, 0x06, 0x6e, 0xa8, 0x0a, 0x61, 0x2e, 0x05,
				0x68, 0xf4, 0x2a, 0xc2, 0xf8, 0xbe, 0x01, 0xbb, 0x5a, 0xb1, 0xd4, 0xa5, 0x5b, 0x7a, 0x35, 0xd7,
				0x80, 0x10, 0x07, 0xec, 0x32, 0x37, 0x00, 0x00, 0x01, 0x01, 0x08, 0x0a, 0x39, 0x7e, 0xc4, 0x1a,
				0x1d, 0xaa, 0x9a, 0x18,
			},
			SrcIp: 3232235521,
			DstIp: 3232235522,
		},
		&pb.Packet{
			Data: []byte{
				// Note:
				// Identification and checksum field of outer IP header is 0x00 since they will be computed dynamically and cannot test here.
				// Following test cases are also same as this one.
				0x45, 0x00, 0x00, 0x48, 0x00, 0x00, 0x40, 0x00, 0x3f, 0x04, 0x00, 0x00, 0xc0, 0xa8, 0x00, 0x01,
				0xc0, 0xa8, 0x00, 0x02,
				0x45, 0x00, 0x00, 0x34, 0x00, 0x00, 0x40, 0x00, 0x40, 0x06, 0x6e, 0xa8, 0x0a, 0x61, 0x2e, 0x05,
				0x68, 0xf4, 0x2a, 0xc2, 0xf8, 0xbe, 0x01, 0xbb, 0x5a, 0xb1, 0xd4, 0xa5, 0x5b, 0x7a, 0x35, 0xd7,
				0x80, 0x10, 0x07, 0xec, 0x32, 0x37, 0x00, 0x00, 0x01, 0x01, 0x08, 0x0a, 0x39, 0x7e, 0xc4, 0x1a,
				0x1d, 0xaa, 0x9a, 0x18,
			},
		},
	},
}

func TestEncapsulate(t *testing.T) {
	s := &pktcapsuleServer{}
	ctx := context.Background()

	for _, tt := range encapsulateTests {
		pkt, _ := s.Encapsulate(ctx, tt.in)
		// check before identification field
		if !bytes.Equal(pkt.Data[:4], tt.out.Data[:4]) {
			t.Errorf("Encapsulate()[:4] = % x, but got % x\n", tt.out.Data[:4], pkt.Data[:4])
		}
		// check between identification and checksum field
		if !bytes.Equal(pkt.Data[6:10], tt.out.Data[6:10]) {
			t.Errorf("Encapsulate()[6:10] = % x, but got % x\n", tt.out.Data[6:10], pkt.Data[6:10])
		}
		// check after checksum field
		if !bytes.Equal(pkt.Data[12:], tt.out.Data[12:]) {
			t.Errorf("Encapsulate()[12:] = % x, but got % x\n", tt.out.Data[12:], pkt.Data[12:])
		}
	}
}

var decapsulateTests = []struct {
	in  *pb.DecapsulateRequest
	out *pb.Packet
}{
	{
		&pb.DecapsulateRequest{
			Data: []byte{
				// Note:
				// Identification and checksum field of outer IP header is 0x00 since they will be computed dynamically and cannot test here.
				// Following test cases are also same as this one.
				0x45, 0x00, 0x00, 0x48, 0x00, 0x00, 0x40, 0x00, 0x3f, 0x04, 0x00, 0x00, 0xc0, 0xa8, 0x00, 0x01,
				0xc0, 0xa8, 0x00, 0x02,
				0x45, 0x00, 0x00, 0x34, 0x00, 0x00, 0x40, 0x00, 0x40, 0x06, 0x6e, 0xa8, 0x0a, 0x61, 0x2e, 0x05,
				0x68, 0xf4, 0x2a, 0xc2, 0xf8, 0xbe, 0x01, 0xbb, 0x5a, 0xb1, 0xd4, 0xa5, 0x5b, 0x7a, 0x35, 0xd7,
				0x80, 0x10, 0x07, 0xec, 0x32, 0x37, 0x00, 0x00, 0x01, 0x01, 0x08, 0x0a, 0x39, 0x7e, 0xc4, 0x1a,
				0x1d, 0xaa, 0x9a, 0x18,
			},
		},
		&pb.Packet{
			Data: []byte{
				0x45, 0x00, 0x00, 0x34, 0x00, 0x00, 0x40, 0x00, 0x40, 0x06, 0x6e, 0xa8, 0x0a, 0x61, 0x2e, 0x05,
				0x68, 0xf4, 0x2a, 0xc2, 0xf8, 0xbe, 0x01, 0xbb, 0x5a, 0xb1, 0xd4, 0xa5, 0x5b, 0x7a, 0x35, 0xd7,
				0x80, 0x10, 0x07, 0xec, 0x32, 0x37, 0x00, 0x00, 0x01, 0x01, 0x08, 0x0a, 0x39, 0x7e, 0xc4, 0x1a,
				0x1d, 0xaa, 0x9a, 0x18,
			},
		},
	},
}

func TestDecapsulate(t *testing.T) {
	s := &pktcapsuleServer{}
	ctx := context.Background()

	for _, tt := range decapsulateTests {
		pkt, _ := s.Decapsulate(ctx, tt.in)
		if !reflect.DeepEqual(pkt, tt.out) {
			t.Errorf("Decapsulate() = %+v, but got %+v\n", tt.out, pkt)
		}
	}
}
